# 12865 평범한 배낭 (0/1 Knapsack)
# - 물건 N개 (각각 무게 W, 가치 V)
# - 배낭은 최대 무게 K까지 담을 수 있음
# - 각 물건은 "최대 1번"만 담을 수 있음 (0/1 배낭)
# - 목표: 무게 K를 넘지 않으면서 가치 합의 최댓값 출력

import sys
input = sys.stdin.readline

# N: 물건 개수, K: 배낭 최대 허용 무게
N, K = map(int, input().split())

# dp[w]의 의미:
#   "현재까지 고려한 물건들만 사용해서,
#    배낭에 담은 총 무게가 정확히 w(또는 w 이하로 맞춘 상태)일 때 얻을 수 있는 최대 가치"
#
# 구현에서는 dp[w]를 "무게 w 이하에서의 최대 가치"처럼 사용해도 됨.
# 이유: dp 갱신이 max로 누적되면서 결국 w 용량 내 최대 가치가 dp[w]에 반영됨.
#
# dp 크기: 0 ~ K 까지 필요하므로 K+1
dp = [0] * (K + 1)

# 물건을 하나씩 읽으면서 dp를 갱신한다.
for _ in range(N):
    
    # W: 이 물건의 무게, V: 이 물건의 가치
    W, V = map(int, input().split())


    # w를 K -> W 방향(큰 값에서 작은 값)으로 내려오면서 dp를 업데이트한다.
    
    # 왜 뒤에서부터?
    # - 0/1 배낭은 "각 물건을 최대 1번"만 쓸 수 있어야 함.
    # - dp[w]를 업데이트할 때 참고하는 dp[w - W]는
    #   "이번 물건을 아직 반영하기 전 상태"여야 한다.
    
    # 만약 앞에서부터( W -> K )로 올려가며 갱신하면
    #   dp[w - W]가 같은 반복(같은 물건)에서 이미 업데이트된 값일 수 있어서
    #   결과적으로 "같은 물건을 여러 번 넣는" 상황이 발생함 (무한 배낭처럼 동작).
    
    # 따라서, 뒤에서부터 갱신하면:
    # - dp[w - W]는 아직 '이번 물건'을 반영하지 않은 이전 상태이므로
    # - '이번 물건'이 정확히 1번만 사용되는 효과가 보장된다.

    for w in range(K, W - 1, -1):
        # 현재 용량이 w일 때,
        # 1) 이 물건을 안 넣는 경우: dp[w] (기존 값 유지)
        # 2) 이 물건을 넣는 경우:
        #    - 이 물건 무게 W를 추가로 담아야 하므로,
        #      그 전에 무게 (w - W)를 만들었어야 함
        #    - 그때 얻을 수 있는 최대 가치가 dp[w - W]
        #    - 이번 물건 가치 V를 더하면 dp[w - W] + V
        #
        # 둘 중 더 큰 값을 선택해서 dp[w]를 갱신한다.
        dp[w] = max(dp[w], dp[w - W] + V)

# 최종적으로 dp[K]는 "무게 제한 K를 넘지 않으면서 얻을 수 있는 최대 가치"가 된다.
print(dp[K])