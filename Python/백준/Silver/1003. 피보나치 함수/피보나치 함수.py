# 시간 초과 ----------------------------------------------------------

    # # 전역 변수 c0, c1 선언 (피보나치 함수에서 0과 1이 몇 번 호출되는지 카운트)
    # c0, c1 = 0, 0

    # def fibonacci(n) :
    #     global c0, c1  # 함수 내부에서 전역 변수 c0, c1을 사용 선언
    #     if n == 0 :
    #         c0 += 1    # n == 0일 때 호출된 횟수를 기록
    #         return 0
    #     elif n == 1 :
    #         c1 += 1    # n == 1일 때 호출된 횟수를 기록
    #         return 1
    #     else :
    #         return fibonacci(n-1) + fibonacci(n-2)

    # t = int(input())

    # for _ in range(t) :
    #     c0, c1 = 0, 0     # 매 테스트케이스마다 c0, c1을 0으로 초기화

    #     n = int(input())
    #     fibonacci(n)
    #     print(c0, c1)

# --------------------------------------------------------------------


# 다이나믹 프로그래밍 (DP) 사용
# 다이나믹 프로그래밍(또는 동적 계획법)은 기본적인 아이디어로 하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용하는 것
# 왜 DP를 사용할까? 사실 일반적인 재귀(Naive Recursion) 방식 또한 DP와 매우 유사하다. 큰 차이점은 일반적인 재귀를 단순히 사용 시 동일한 작은 문제들이 여러 번 반복 되어 비효율적인 계산될 수 있다는 것이다.
# DP는 기본적으로 문제를 나누고 그 문제의 결과 값을 재활용해서 전체 답을 구한다. 그래서 동일한 작은 문제들이 반복하여 나타나는 경우에 사용이 가능

t = int(input())

for _ in range(t):
    n = int(input())

    # 0과 1의 호출 횟수(N은 40보다 작거나 같은 자연수 또는 0)
    zero = [0] * (41)
    one = [0] * (41)
    
    zero[0], one[0] = 1, 0 # f(0)
    zero[1], one[1] = 0, 1 # f(1)

    for i in range(2, n+1): # f(n)이 될 때까지 피보나치 호출 반복
        zero[i] = zero[i-1] + zero[i-2]
        one[i] = one[i-1] + one[i-2]

    print(zero[n], one[n])
